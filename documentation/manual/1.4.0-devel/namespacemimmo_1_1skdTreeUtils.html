
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="description" content="mimmo is a C++ library for manipulation and morphing surface and volume meshes." />
    <meta name="keywords" content="mimmo, HPC, STL, CGNS, morphing, optimization, radial basis function, free form deformation, mesh, grid" />
    <link rel="shortcut icon" href="/mimmo/images/mimmo_ico.png" type="image/x-icon">
    <link rel="icon" href="/mimmo/images/mimmo_ico.png" type="image/x-icon">
    <link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Lato:400,700'>
    <link rel="stylesheet" type="text/css" href="/mimmo/stylesheets/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/mimmo/stylesheets/base.css" />
    <link rel="stylesheet" type="text/css" href="/mimmo/stylesheets/cookies.css" />
    <script type="text/javascript" src="/mimmo/scripts/jquery-1.12.4.min.js"></script>
    <script type="text/javascript" src="/mimmo/scripts/cookies.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-96644314-1', 'auto');
  ga('send', 'pageview');
</script>
    <script type="text/javascript">
        $(document).ready(function(){
        });
    </script>
    <meta name="generator" content="Doxygen 1.8.17"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="manual.css" rel="stylesheet" type="text/css"/>
    <title>mimmo - Manual - mimmo::skdTreeUtils Namespace Reference</title>
</head>
<body>
<div id="cookie-warning">
        <p id="accept-cookies" class="button">Continue</p>
        <h3>Our website uses cookies</h3>
        <p>
        This website uses cookies. By continuing to use this website you are
        giving consent to cookies being used. For information on cookies
        and how you can disable them visit our
        <a href="/mimmo/privacy.html">Privacy Policy</a>.
        </p>
</div>
<!-- Header-->
<div id="header" class="">
    <div class="logo"><a href="/mimmo">&nbsp;</a></div>
    <div class="menu-line"></div>
<ul class="menu">
    <li>
        <a href="/mimmo/overview">Overview</a>
    </li>
    <li class="current">
        <span>Documentation</span>
        <ul class="sub-menu">
            <li><a href="/mimmo/documentation/installation.html">Installation guide</a></li>
            <li><a href="/mimmo/documentation/manual/1.4.0-devel/index.html">Programmer's manual</a></li>
        </ul>
    </li>
    <li>
        <a href="/mimmo/downloads">Downloads</a>
    </li>
</ul>
<script type="text/javascript">
$('.menu li').hover(
    function() {
        $('ul', this).css('height', 'auto');
        $('ul', this).stop().slideDown(200);
    },
    function() {
        $('ul', this).stop().slideUp(200, function() {
            $(this).attr('style','');
        });
    }
);
</script>
</div>
<div id="content" class="">
<div id="manual">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mimmo</b></li><li class="navelem"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html">skdTreeUtils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mimmo::skdTreeUtils Namespace Reference<div class="ingroups"><a class="el" href="group__core.html">core</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Utilities employing SkdTree.  
<a href="namespacemimmo_1_1skdTreeUtils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5bbbf96209f0dc2288ce5325b47f6469"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a5bbbf96209f0dc2288ce5325b47f6469">checkPointBelongsToCell</a> (const std::array&lt; double, 3 &gt; &amp;point, const bitpit::SurfUnstructured *surface_mesh, long cellId)</td></tr>
<tr class="separator:a5bbbf96209f0dc2288ce5325b47f6469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985348c7214364c3b6e16c452818dc6a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a985348c7214364c3b6e16c452818dc6a">computePseudoNormal</a> (const std::array&lt; double, 3 &gt; &amp;point, const bitpit::SurfUnstructured *surface_mesh, long id, std::array&lt; double, 3 &gt; &amp;pseudo_normal)</td></tr>
<tr class="separator:a985348c7214364c3b6e16c452818dc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122175eacb1309236f2adafa0d813f5c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a122175eacb1309236f2adafa0d813f5c">distance</a> (const std::array&lt; double, 3 &gt; *point, const bitpit::PatchSkdTree *tree, long &amp;id, double r)</td></tr>
<tr class="separator:a122175eacb1309236f2adafa0d813f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff8664308099d01a92a3a01e3aea41e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a6ff8664308099d01a92a3a01e3aea41e">distance</a> (int nP, const std::array&lt; double, 3 &gt; *points, const bitpit::PatchSkdTree *tree, long *ids, double *distances, double *r)</td></tr>
<tr class="separator:a6ff8664308099d01a92a3a01e3aea41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfe395ce28f3c10604b5576fe5c9648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a6dfe395ce28f3c10604b5576fe5c9648">distance</a> (int nP, const std::array&lt; double, 3 &gt; *points, const bitpit::PatchSkdTree *tree, long *ids, double *distances, double r)</td></tr>
<tr class="separator:a6dfe395ce28f3c10604b5576fe5c9648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581ecb17c696b4fc09acd9da9e602ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a581ecb17c696b4fc09acd9da9e602ef8">extractTarget</a> (bitpit::PatchSkdTree *target, const std::vector&lt; const bitpit::SkdNode * &gt; &amp;leafSelection, std::vector&lt; long &gt; &amp;extracted, double tol)</td></tr>
<tr class="separator:a581ecb17c696b4fc09acd9da9e602ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2bb42ef5c11409aecefd5c9e61426b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a1a2bb42ef5c11409aecefd5c9e61426b">findPointClosestCell</a> (const std::array&lt; double, 3 &gt; &amp;point, const bitpit::PatchSkdTree *tree, bool interiorOnly, long *id, double *<a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a122175eacb1309236f2adafa0d813f5c">distance</a>)</td></tr>
<tr class="separator:a1a2bb42ef5c11409aecefd5c9e61426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5593fe6211b00942d6d87915278825"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a1b5593fe6211b00942d6d87915278825">findPointClosestCell</a> (const std::array&lt; double, 3 &gt; &amp;point, const bitpit::PatchSkdTree *tree, double maxDistance, bool interiorOnly, long *id, double *<a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a122175eacb1309236f2adafa0d813f5c">distance</a>)</td></tr>
<tr class="separator:a1b5593fe6211b00942d6d87915278825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734cda738c28d89349a4c817f230be3b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a734cda738c28d89349a4c817f230be3b">locatePointOnPatch</a> (const std::array&lt; double, 3 &gt; &amp;point, const bitpit::PatchSkdTree *tree)</td></tr>
<tr class="separator:a734cda738c28d89349a4c817f230be3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df98956ae254b593657f1110b1717ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga5df63afb31922e8b4ada0a5cc96ad765">darray3E</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a0df98956ae254b593657f1110b1717ab">projectPoint</a> (const std::array&lt; double, 3 &gt; *point, const bitpit::PatchSkdTree *skdtree, double r)</td></tr>
<tr class="separator:a0df98956ae254b593657f1110b1717ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08961b47006debf6d3a128cba4bb920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#af08961b47006debf6d3a128cba4bb920">projectPoint</a> (int nP, const std::array&lt; double, 3 &gt; *points, const bitpit::PatchSkdTree *tree, std::array&lt; double, 3 &gt; *projected_points, long *ids, double *r)</td></tr>
<tr class="separator:af08961b47006debf6d3a128cba4bb920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862fab77c75961ef4dad862e0c103152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a862fab77c75961ef4dad862e0c103152">projectPoint</a> (int nP, const std::array&lt; double, 3 &gt; *points, const bitpit::PatchSkdTree *tree, std::array&lt; double, 3 &gt; *projected_points, long *ids, double r)</td></tr>
<tr class="separator:a862fab77c75961ef4dad862e0c103152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ff255461bf91cfb197453e2bbf9819"><td class="memItemLeft" align="right" valign="top">std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a06ff255461bf91cfb197453e2bbf9819">selectByPatch</a> (bitpit::PatchSkdTree *selection, bitpit::PatchSkdTree *target, double tol)</td></tr>
<tr class="separator:a06ff255461bf91cfb197453e2bbf9819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dcee27c4f51ad3687a9e54f40aa7f2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a35dcee27c4f51ad3687a9e54f40aa7f2">signedDistance</a> (const std::array&lt; double, 3 &gt; *point, const bitpit::PatchSkdTree *tree, long &amp;id, std::array&lt; double, 3 &gt; &amp;normal, double r)</td></tr>
<tr class="separator:a35dcee27c4f51ad3687a9e54f40aa7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099aa711acaf40bf08462296ee7d3493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a099aa711acaf40bf08462296ee7d3493">signedDistance</a> (int nP, const std::array&lt; double, 3 &gt; *points, const bitpit::PatchSkdTree *tree, long *ids, double *distances, std::array&lt; double, 3 &gt; *normals, double *r)</td></tr>
<tr class="separator:a099aa711acaf40bf08462296ee7d3493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e88361e01bd1fce05999e97f61c706d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemimmo_1_1skdTreeUtils.html#a5e88361e01bd1fce05999e97f61c706d">signedDistance</a> (int nP, const std::array&lt; double, 3 &gt; *points, const bitpit::PatchSkdTree *tree, long *ids, double *distances, std::array&lt; double, 3 &gt; *normals, double r)</td></tr>
<tr class="separator:a5e88361e01bd1fce05999e97f61c706d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utilities employing SkdTree. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5bbbf96209f0dc2288ce5325b47f6469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbbf96209f0dc2288ce5325b47f6469">&#9670;&nbsp;</a></span>checkPointBelongsToCell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mimmo::skdTreeUtils::checkPointBelongsToCell </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::SurfUnstructured *&#160;</td>
          <td class="paramname"><em>surface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cellId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It check if a point belongs to an input cell. If the point is located on the plane of the cell and inside it, it returns true, false otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>point coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface_mesh</td><td>pointer to surface mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellId</td><td>cell id belong to the input surface mesh to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point belongs to the input cell </dd></dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00592">592</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a985348c7214364c3b6e16c452818dc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985348c7214364c3b6e16c452818dc6a">&#9670;&nbsp;</a></span>computePseudoNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mimmo::skdTreeUtils::computePseudoNormal </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::SurfUnstructured *&#160;</td>
          <td class="paramname"><em>surface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pseudo_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the pseudo-normal of a cell of a surface mesh from an input point, i.e. the unit vector with direction (P-xP), where P is the input point and xP is the projection on the cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>coordinates of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface_mesh</td><td>pointer to surface mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>cell id belong to the input surface mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pseudo_normal</td><td>3-components array representing the pseudo-normal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>+/- 1.0 to identify if the pseudo normal is pointing in the same direction of the local surface normal or in the opposite side. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00517">517</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a122175eacb1309236f2adafa0d813f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122175eacb1309236f2adafa0d813f5c">&#9670;&nbsp;</a></span>distance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mimmo::skdTreeUtils::distance </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the unsigned distance of a point to a geometry linked in a SkdTree object. The geometry has to be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). It searches the element with minimum distance in a box of length 2*r, if none is found return a default value of distance equal to std::numeric_limits&lt;double&gt;::max(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Pointer to coordinates of input point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Pointer to Boundary Volume Hierarchy tree that stores the geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>Label of the element found as minimum distance element in the skd-tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Length of the side of the box or radius of the sphere used to search. (The algorithm checks every element encountered inside the box/sphere). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unsigned distance of the input point from the patch in the skd-tree. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00049">49</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a6ff8664308099d01a92a3a01e3aea41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff8664308099d01a92a3a01e3aea41e">&#9670;&nbsp;</a></span>distance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mimmo::skdTreeUtils::distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the unsigned distance of a set of points to a geometry linked in a SkdTree object. The geometry has to be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). It searches the element with minimum distance in a box of length 2*r, if none is found return a default value of distance equal to std::numeric_limits&lt;double&gt;::max() in the position of the distances array related to the input point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nP</td><td>Number of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Pointer to coordinates of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Pointer to Boundary Volume Hierarchy tree that stores the geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>Unsigned distance of the input points from the patch in the skd-tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Label of the elements found as minimum distance elements in the skd-tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Length of the side of the box or radius of the sphere used to search for each input point. (The algorithm checks every element encountered inside the box/sphere). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00140">140</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a6dfe395ce28f3c10604b5576fe5c9648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfe395ce28f3c10604b5576fe5c9648">&#9670;&nbsp;</a></span>distance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mimmo::skdTreeUtils::distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the unsigned distance of a set of points to a geometry linked in a SkdTree object. The geometry has to be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). It searches the element with minimum distance in a box of length 2*r, if none is found return a default value of distance equal to std::numeric_limits&lt;double&gt;::max() in the position of the distances array related to the input point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nP</td><td>Number of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Pointer to coordinates of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Pointer to Boundary Volume Hierarchy tree that stores the geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>Unsigned distance of the input points from the patch in the skd-tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Label of the elements found as minimum distance elements in the skd-tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Length of the side of the box or radius of the sphere used to search. (The algorithm checks every element encountered inside the box/sphere). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00119">119</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a581ecb17c696b4fc09acd9da9e602ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581ecb17c696b4fc09acd9da9e602ef8">&#9670;&nbsp;</a></span>extractTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mimmo::skdTreeUtils::extractTarget </td>
          <td>(</td>
          <td class="paramtype">bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const bitpit::SkdNode * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leafSelection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>extracted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It extracts the elements of a leaf node of geometry stored in a skd-tree by a distance criterion in respect to an other geometry stored in a different skd-tree. It is a method used in selectByPatch method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Pointer to skd-tree that store the target geometry. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">leafSelection</td><td>Vector of pointers to the leaf nodes currently interesting for the selection procedure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">extracted</td><td>of the label of all the elements of the target skd-tree, currently found placed at a distance &lt;= tol from the bounding boxes of the leaf nodes in leafSelection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Distance threshold used to select the elements of target. the next-th node is not a leaf node the method is recursively called. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00296">296</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a1a2bb42ef5c11409aecefd5c9e61426b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2bb42ef5c11409aecefd5c9e61426b">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mimmo::skdTreeUtils::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interiorOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified point find the closest cell contained in a skd-tree and evaluates the distance between that cell and the given point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>pointer to SkdTree relative to the target volume geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interiorOnly</td><td>if set to true, only interior cells will be considered, it will be possible to consider non-interior cells only if the tree has been instantiated with non-interior cells support enabled </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>on output it will contain the id of the cell closest to the point, if the distance between the point and the surface is greater than the specified maximum distance, the id parameter will be set to the null id </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">distance</td><td>on output it will contain the distance between the point and closest cell. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l01538">1538</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a1b5593fe6211b00942d6d87915278825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5593fe6211b00942d6d87915278825">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mimmo::skdTreeUtils::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interiorOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified point find the closest cell contained in a skd-tree and evaluates the distance between that cell and the given point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>pointer to SkdTree relative to the target volume geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interiorOnly</td><td>if set to true, only interior cells will be considered, it will be possible to consider non-interior cells only if the tree has been instantiated with non-interior cells support enabled </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>on output it will contain the id of the closest cell. If all cells contained in the tree are farther than the maximum distance, the argument will be set to the null id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance</td><td>on output it will contain the distance between the point and closest cell. If all cells contained in the tree are farther than the maximum distance, the argument will be set to the maximum representable distance </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l01564">1564</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a734cda738c28d89349a4c817f230be3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734cda738c28d89349a4c817f230be3b">&#9670;&nbsp;</a></span>locatePointOnPatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mimmo::skdTreeUtils::locatePointOnPatch </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified point find the cell of a surface patch it is into. The method works only with trees generated with bitpit::SurfUnstructured mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>reference to SkdTree relative to the target surface geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of the geometry cell the point is into. Return bitpit::Cell::NULL_ID if no cell is found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00456">456</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a0df98956ae254b593657f1110b1717ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df98956ae254b593657f1110b1717ab">&#9670;&nbsp;</a></span>projectPoint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; mimmo::skdTreeUtils::projectPoint </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>skdtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the projection of a point on a geometry linked in a skd-tree object. The geometry must be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). It searches the elements of the geometry with minimum distance recursively in a sphere of radius r, by increasing the size r at each step until at least one element is found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Pointer to coordinates of input point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skdtree</td><td>Pointer to Boundary Volume Hierarchy tree that stores the geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Initial length of the sphere radius used to search. (The algorithm checks every element encountered inside the sphere). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Coordinates of the projected point. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00375">375</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="af08961b47006debf6d3a128cba4bb920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08961b47006debf6d3a128cba4bb920">&#9670;&nbsp;</a></span>projectPoint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mimmo::skdTreeUtils::projectPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>projected_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the projection of a set of points on a geometry linked in a skd-tree object. The geometry must be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). It searches the elements of the geometry with minimum distance recursively in a sphere of radius r, by increasing the size r at each step until at least one element is found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nP</td><td>Number of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Pointer to coordinates of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Pointer to Boundary Volume Hierarchy tree that stores the geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projected_points</td><td>Coordinates of the projected points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Labels of the elements found as minimum distance element into the points are projected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>pointer to a list of initial search sphere radii. (The algorithm checks for every point i every element encountered inside the sphere of i-th radius). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00419">419</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a862fab77c75961ef4dad862e0c103152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862fab77c75961ef4dad862e0c103152">&#9670;&nbsp;</a></span>projectPoint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mimmo::skdTreeUtils::projectPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>projected_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the projection of a set of points on a geometry linked in a skd-tree object. The geometry must be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). It searches the elements of the geometry with minimum distance recursively in a sphere of radius r, by increasing the size r at each step until at least one element is found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nP</td><td>Number of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Pointer to coordinates of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Pointer to geometry Skdtree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projected_points</td><td>Coordinates of projected points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Labels of cells found as minimum distance element support for projected points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Initial length of the sphere radius used to search. (The algorithm checks every element encountered inside the sphere). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00398">398</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a06ff255461bf91cfb197453e2bbf9819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ff255461bf91cfb197453e2bbf9819">&#9670;&nbsp;</a></span>selectByPatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; long &gt; mimmo::skdTreeUtils::selectByPatch </td>
          <td>(</td>
          <td class="paramtype">bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It selects the elements of a geometry stored in a skd-tree by a distance criterion in respect to an other geometry stored in a different skd-tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">selection</td><td>Pointer to skd-tree used as selection patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Pointer to skd-tree that store the target geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Distance threshold used to select the elements of target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of the label of all the elements of the target skd-tree placed at a distance &lt;= tol from the bounding boxes of the leaf nodes of the skd-tree selection. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00251">251</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a35dcee27c4f51ad3687a9e54f40aa7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dcee27c4f51ad3687a9e54f40aa7f2">&#9670;&nbsp;</a></span>signedDistance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mimmo::skdTreeUtils::signedDistance </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the signed distance of a point to a geometry linked in a SkdTree object. The geometry must be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). The sign of the distance is provided by the normal to the geometry locally computed. A positive distance means that the point is located, in respect to the surface mesh, on the same side of the outer normal vector. It searches the element with minimum distance in a box of length 2*r, if none is found return a default value of distance equal to std::numeric_limits&lt;double&gt;::max(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Pointer to coordinates of input point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Pointer to Boundary Volume Hierarchy tree that stores the geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>Label of the element found as minimum distance element in the skd-tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>Pseudo-normal of the element (i.e. unit vector with direction (P-xP), where P is the input point and xP the nearest point on the element (simplex) to the projection of P on the plane of the simplex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Length of the side of the box or radius of the sphere used to search. (The algorithm checks every element encountered inside the box/sphere). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed distance of the input point from the patch in the skd-tree. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00084">84</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a099aa711acaf40bf08462296ee7d3493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099aa711acaf40bf08462296ee7d3493">&#9670;&nbsp;</a></span>signedDistance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mimmo::skdTreeUtils::signedDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the signed distance of a set of points to a geometry linked in a SkdTree object. The geometry must be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). The sign of the distance is provided by the normal to the geometry locally computed. A positive distance means that the point is located, in respect to the surface mesh, on the same side of the outer normal vector. It searches the element with minimum distance in a box of length 2*r, if none is found return a default value of distance equal to std::numeric_limits&lt;double&gt;::max() in the position of the distances array related to the input point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nP</td><td>Number of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Pointer to coordinates of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Pointer to Boundary Volume Hierarchy tree that stores the geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>Signed distance of the input points from the patch in the skd-tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Label of the elements found as minimum distance elements in the skd-tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Pseudo-normal of the elements (i.e. unit vector with direction (P-xP), where P is the input point and xP the nearest point on the element (simplex) to the projection of P on the plane of the simplex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Length of the side of the box or radius of the sphere used to search for each input point. (The algorithm checks every element encountered inside the box/sphere). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00213">213</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
<a id="a5e88361e01bd1fce05999e97f61c706d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e88361e01bd1fce05999e97f61c706d">&#9670;&nbsp;</a></span>signedDistance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mimmo::skdTreeUtils::signedDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitpit::PatchSkdTree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It computes the signed distance of a set of points to a geometry linked in a SkdTree object. The geometry must be a surface mesh, in particular an object of type bitpit::SurfUnstructured (a static cast is hardly coded in the method). The sign of the distance is provided by the normal to the geometry locally computed. A positive distance means that the point is located, in respect to the surface mesh, on the same side of the outer normal vector. It searches the element with minimum distance in a box of length 2*r, if none is found return a default value of distance equal to std::numeric_limits&lt;double&gt;::max() in the position of the distances array related to the input point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nP</td><td>Number of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Pointer to coordinates of input points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Pointer to Boundary Volume Hierarchy tree that stores the geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>Signed distance of the input points from the patch in the skd-tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Label of the elements found as minimum distance elements in the skd-tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Pseudo-normal of the elements (i.e. unit vector with direction (P-xP), where P is the input point and xP the nearest point on the element (simplex) to the projection of P on the plane of the simplex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Length of the side of the box or radius of the sphere used to search. (The algorithm checks every element encountered inside the box/sphere). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SkdTreeUtils_8cpp_source.html#l00186">186</a> of file <a class="el" href="SkdTreeUtils_8cpp_source.html">SkdTreeUtils.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->

</div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Tue Mar 16 2021 16:26:42 for mimmo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
    <div id="footer" >
        <div class="middle">
            <div class="box-wrapper">
                <div class="box mimmo">
                    <p>
                    <strong><a href="/mimmo">mimmo</a></strong><br />
                    <a href="/mimmo/overview">Overview</a><br />
                    <a href="/mimmo/downloads">Downloads</a>
                    </p>
                </div>
                <div class="box optimad">
                    <p>
                    <strong><a href="http://www.optimad.it">OPTIMAD Engineering Srl</a></strong><br />
                    <a href="http://www.optimad.it/corporate/spin-off/">About</a><br />
                    <a href="http://www.optimad.it/contact-us/">Contact us</a><br />
                    <a href="mailto:info@optimad.it">info@optimad.it</a>
                    </p>
                </div>
                <div class="box address">
                    <p>
                    <strong>Address</strong><br />
                    Via Giacinto Collegno 18<br />
                    10143 Torino<br />
                    Italy
                    </p>
                </div>
                <div class="box info">
                    <p>
                    <strong>Info</strong><br />
                    Capitale Sociale  10.000,00 i.v.<br />
                    C.F. / P.Iva 09359170017<br />
                    Iscr. Reg. Impr. Torino - R.E.A. TO-1045102
                    </p>
                </div>
            </div>
        </div>
        <div class="legal">
                    <p>
                     2016-2017 OPTIMAD Engineering Srl -
                    <a href="/mimmo/privacy.html">Privacy Policy</a>
                    </p>
        </div>
    </div>
</div>
</body>
</html>
